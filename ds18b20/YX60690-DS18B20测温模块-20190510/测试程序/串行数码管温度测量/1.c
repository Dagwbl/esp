
/*********************************************************************************
* 【编写时间】： 2011.07.07
* 【作    者】： 雁翎电子
* 【版    本】： V1.0
* 【网    站】： http://ylelectronic.taobao.com/ 
* 【Q      Q】： 348439350
* 【声    明】： 此程序仅用于学习与参考，引用请注明版权和作者信息！
* 【函数功能】： 利用单线制DS18B20温度传感器  LED数码管显示当前的温度值			   			            			    
* 【使用说明】： 将J1短路帽短接，选择数码管模块
**********************************************************************************/

#include <reg51.h>                 //DS18B20温度传感器程序 
code unsigned char seg7code[]={0xc0,0xf9,0xa4,0xb0,0x99,0x92,
                               0x82,0xf8,0x80,0x90,0xff}; //不带小数点的共阳数码管段码
code unsigned char seg7codeB[]={0x40,0x79,0x24,0x30,0x19,0x12,
                               0x02,0x78,0x00,0x10,0xff}; //带小数点的共阳数码管段码

unsigned char code fseg[]={0xc0,0xf9,0xa4,0xb0,0x99,0x92,0x82,0xf8,0x80,0x90};	//不带小数点的共阳数码管段码
unsigned char code fseg1[]={0x40,0x79,0x24,0x30,0x19,0x12,0x02,0x78,0x00,0x10};	//带小数点的共阳数码管段码
 unsigned char code segbit[]={0x80,0x40,0x20,0x10,0x08,0x04,0x02,0x01};
 unsigned char  disbuf[8]={0,0,0,0,0,0,0,0};

/* 函数申明 -----------------------------------------------*/
void delay(unsigned char i);
void delay1ms(unsigned char i);
void ReadTemperature(void);
void Init_DS18B20(void);
ReadOneChar();
void WriteOneChar(unsigned char dat);
void out(void);
void sdata(void);

/* 变量定义 -----------------------------------------------*/
sbit DQ=P3^6; //数据传输线接单片机的相应的引脚 
unsigned char tempL=0; //设全局变量
unsigned char tempH=0; 
unsigned int sdate;//测量到的温度的整数部分
unsigned char xiaoshu1;//小数第一位
unsigned char xiaoshu2;//小数第二位
unsigned char xiaoshu;//两位小数
bit  fg=1;        //温度正负标志

sbit MOSIO=P2^2;
sbit R_CLKa=P2^3;
sbit S_CLKa=P2^4;
 unsigned char m;

/*
********************************************************************************
** 函数名称 ： main(void)
** 函数功能 ： 主函数
********************************************************************************
*/
void main(void)
{
 while(1)
 {
  ReadTemperature();
  sdata();
   out();
 
 }
}


/*
********************************************************************************
** 函数名称 ： delay(unsigned char i)
** 函数功能 ： 延时函数		这个延时程序的具体延时时间是time=i*8+10,适用于小于2ms的延时
********************************************************************************
*/
void delay(unsigned char i)
{
 	
 	while(i--);
  
  
}

/*
********************************************************************************
** 函数名称 ：  delay1ms(unsigned char i)
** 函数功能 ： 延时函数	
********************************************************************************
*/
void delay1ms(unsigned char i)
{
 for(i=124;i>0;i--);  //延时124*8+10=1002us
}



/*
********************************************************************************
** 函数名称 ： Init_DS18B20(void)
** 函数功能 ： 初始化
********************************************************************************
*/
void Init_DS18B20(void) 
{
 unsigned char x=0;
 DQ=1; //DQ先置高 
 delay(8); //稍延时
 DQ=0; //发送复位脉冲 
 delay(80); //延时（>480us) 
 DQ=1; //拉高数据线 
 delay(5); //等待（15~60us) 
 x=DQ; //用X的值来判断初始化有没有成功，18B20存在的话X=0，否则X=1 
 delay(20); 
} 


/*
********************************************************************************
** 函数名称 ：  ReadOneChar()
** 函数功能 ： 读一个字节
********************************************************************************
*/
 ReadOneChar()  //主机数据线先从高拉至低电平1us以上，再使数据线升为高电平，从而产生读信号
{
unsigned char i=0; //每个读周期最短的持续时间为60us，各个读周期之间必须有1us以上的高电平恢复期
unsigned char dat=0; 
for (i=8;i>0;i--) //一个字节有8位 
{
 DQ=1; 
 delay(1); 
 DQ=0;
 dat>>=1; 
 DQ=1; 
 if(DQ) 
 dat|=0x80; 
 delay(4);
} 
return(dat);
} 


/*
********************************************************************************
** 函数名称 ： WriteOneChar(unsigned char dat)
** 函数功能 ： 写一个字节
********************************************************************************
*/

void WriteOneChar(unsigned char dat) 
{ 
  unsigned char i=0; //数据线从高电平拉至低电平，产生写起始信号。15us之内将所需写的位送到数据线上，
  for(i=8;i>0;i--) //在15~60us之间对数据线进行采样，如果是高电平就写1，低写0发生。 
  {
   DQ=0; //在开始另一个写周期前必须有1us以上的高电平恢复期。 
   DQ=dat&0x01; 
   delay(5); 
   DQ=1; 
   dat>>=1;
  } 
  delay(4);
} 


/*
********************************************************************************
** 函数名称 ： ReadTemperature(void)
** 函数功能 ： 读温度值（低位放tempL;高位放tempH;）
********************************************************************************
*/

void ReadTemperature(void) 
{ 
 Init_DS18B20(); //初始化
 WriteOneChar(0xcc); //跳过读序列号的操作
 WriteOneChar(0x44); //启动温度转换
 delay(125); //转换需要一点时间，延时 
 Init_DS18B20(); //初始化
 WriteOneChar(0xcc); //跳过读序列号的操作 
 WriteOneChar(0xbe); //读温度寄存器（头两个值分别为温度的低位和高位） 
 tempL=ReadOneChar(); //读出温度的低位LSB
 tempH=ReadOneChar(); //读出温度的高位MSB 
  
		if(tempH>0x7f)      //最高位为1时温度是负
		{
		 tempL=~tempL;         //补码转换，取反加一
		 tempH=~tempH+1;       
		 fg=0;      //读取温度为负时fg=0
       }
		sdate = tempL/16+tempH*16;      //整数部分
		xiaoshu1 = (tempL&0x0f)*10/16; //小数第一位
		xiaoshu2 = (tempL&0x0f)*100/16%10;//小数第二位
		xiaoshu=xiaoshu1*10+xiaoshu2; //小数两位

		disbuf[3] =  sdate/10;
		disbuf[2] =  sdate%10;
		disbuf[1] =  xiaoshu1;
		disbuf[0] =  xiaoshu2;

}

/*
********************************************************************************
** 函数名称 ： sdata(void)
** 函数功能 ： 数据传输
********************************************************************************
*/
 

void sdata(void)
{
	unsigned char b,c,num;

 	if(b==0)
	{	
	  b++;
	  num=segbit[m];
 	  for(c=0;c<8;c++)
 	  {
			S_CLKa=0;
	 	    MOSIO=num&0x80;
 		    num<<=1;
	 	    S_CLKa=1;
	  }
	
	} 

	if(b==1)

	{  
	    b--;
	  if(m==2)
	  {num=fseg1[disbuf[m]];}
	  else
	   {num=fseg[disbuf[m]];}

 		for(c=0;c<8;c++)
 		  {  S_CLKa=0;
			 MOSIO=num&0x80;
			 num<<=1;
			 S_CLKa=1;
 		  }
	
	}
	     m++;
	     if(m==4)
		 {m=0;
	   	  }
 }



/*
********************************************************************************
** 函数名称 ： out(void)
** 函数功能 ： 数据输出
********************************************************************************
*/

void out(void)
 { 
 	R_CLKa=0;
    delay(1);
    R_CLKa=1;
 } 


